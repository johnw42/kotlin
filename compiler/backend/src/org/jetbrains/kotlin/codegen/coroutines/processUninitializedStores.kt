/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.codegen.coroutines

import org.jetbrains.kotlin.codegen.optimization.common.CustomFramesMethodAnalyzer
import org.jetbrains.kotlin.codegen.optimization.common.OptimizationBasicInterpreter
import org.jetbrains.kotlin.codegen.optimization.common.insnListOf
import org.jetbrains.org.objectweb.asm.Opcodes
import org.jetbrains.org.objectweb.asm.Type
import org.jetbrains.org.objectweb.asm.tree.*
import org.jetbrains.org.objectweb.asm.tree.analysis.BasicValue
import org.jetbrains.org.objectweb.asm.tree.analysis.Frame
import org.jetbrains.org.objectweb.asm.tree.analysis.Interpreter

/**
 * In cases like:
 * NEW
 * DUP
 * LDC "OK"
 * ASTORE 1
 * ASTORE 2
 * ASTORE 3
 * INVOKE suspensionPoint
 * ALOAD 3
 * ALOAD 2
 * ALOAD 1
 * INVOKESPECIAL <init>(String)

 * Replace store/load instruction with moving NEW/DUP after suspension point:
 * LDC "OK"
 * ASTORE 3
 * INVOKE suspensionPoint
 * ALOAD 3
 * ASTORE 4
 * NEW
 * DUP
 * ALOAD 4
 * INVOKESPECIAL <init>(String)
 *
 * This needed because later we spill this variables containing uninitialized object into fields -> leads to VerifyError
 * Note that this transformation changes semantics a bit (class <clinit> may be invoked by NEW instruction)
 * TODO: current implementation affects all store/loads of uninitialized objects, even valid ones:
 * MyClass(try { 1 } catch (e: Exception) { 0 }) // here uninitialized MyClass-object is being spilled before try-catch and then loaded
 *
 * How this works:
 * 1. For each invokespecial <init> determine if NEW uninitialized value was saved to local at least once
 * 2. If it wasn't then do nothing
 * 3. If it was then:
 *   - remove all relevant NEW/DUP/LOAD/STORE instructions
 *   - spill rest of constructor arguments to new local vars
 *   - generate NEW/DUP
 *   - restore constructor arguments
 */
internal fun processUninitializedStores(methodNode: MethodNode) {
    val interpreter = UninitializedNewValueMarkerInterpreter()
    val frames = CustomFramesMethodAnalyzer("fake", methodNode, interpreter, ::UninitializedNewValueFrame).analyze()

    for ((index, insn) in methodNode.instructions.toArray().withIndex()) {
        if (!insn.isConstructorCall()) continue
        val frame = frames[index] ?: continue
        val (uninitializedValue, constructorArgument) = frame.getUninitializedValueAndCopyForConstructorCall(insn) ?: continue

        val copyUsages: Set<AbstractInsnNode> = interpreter.newToCopyUsages[uninitializedValue.anewInsn]!!
        assert(copyUsages.size > 0) { "At least DUP copy operation expected" }

        // Value generated by NEW wasn't store to local/field (only DUPed)
        if (copyUsages.size == 1) continue

        (copyUsages + uninitializedValue.anewInsn).forEach {
            methodNode.instructions.remove(it)
        }

        val indexOfConstructorArgument = (0 until frame.stackSize).first { frame.getStack(frame.stackSize - 1 - it) === constructorArgument }
        val storedTypes = arrayListOf<Type>()
        var nextVarIndex = methodNode.maxLocals

        for (i in 0 until indexOfConstructorArgument) {
            val value = frame.getStack(frame.stackSize - 1 - i)
            if (value == BasicValue.UNINITIALIZED_VALUE) continue
            val type = value.type
            methodNode.instructions.insertBefore(insn, VarInsnNode(type.getOpcode(Opcodes.ISTORE), nextVarIndex))
            nextVarIndex += type.size
            storedTypes.add(type)
        }
        methodNode.maxLocals = Math.max(methodNode.maxLocals, nextVarIndex)

        methodNode.instructions.insertBefore(insn, insnListOf(
            TypeInsnNode(Opcodes.NEW, uninitializedValue.anewInsn.desc),
            InsnNode(Opcodes.DUP)
        ))

        for (type in storedTypes) {
            nextVarIndex -= type.size
            methodNode.instructions.insertBefore(insn, VarInsnNode(type.getOpcode(Opcodes.ILOAD), nextVarIndex))
        }
    }
}

private class UninitializedNewValue(
        val anewInsn: TypeInsnNode, val internalName: String
) : BasicValue(Type.getObjectType(internalName)) {
    override fun toString() = "UninitializedNewValue(internalName='$internalName')"
}

private class UninitializedNewValueFrame(nLocals: Int, nStack: Int) : Frame<BasicValue>(nLocals, nStack) {
    override fun execute(insn: AbstractInsnNode, interpreter: Interpreter<BasicValue>?) {
        val replaceTopValueWithInitialized = getUninitializedValueAndCopyForConstructorCall(insn) != null

        super.execute(insn, interpreter)

        if (replaceTopValueWithInitialized) {
            // Drop top value
            val value = pop() as UninitializedNewValue

            // uninitialized value become initialized after <init> call
            push(BasicValue(value.type))
        }
    }
}

/**
 * @return values generated by NEW/DUP operations
 */
private fun Frame<BasicValue>.getUninitializedValueAndCopyForConstructorCall(
        insn: AbstractInsnNode
): Pair<UninitializedNewValue, UninitializedNewValue>? {
    if (insn.isConstructorCall()) {
        assert(insn.opcode == Opcodes.INVOKESPECIAL) { "Expected opcode Opcodes.INVOKESPECIAL for <init>, but ${insn.opcode} found" }
        val paramsSize = Type.getArgumentsAndReturnSizes((insn as MethodInsnNode).desc) shr 2
        val constructorReceiver = getStack(stackSize - paramsSize)

        if (constructorReceiver is UninitializedNewValue) {
            assert(getStack(stackSize - (paramsSize + 1)) is UninitializedNewValue) {
                "Previous value before DUPed one should be UninitializedNewValue"
            }

            return Pair(getStack(stackSize - (paramsSize + 1)) as UninitializedNewValue, constructorReceiver)
        }
    }

    return null
}

private fun AbstractInsnNode.isConstructorCall() = this is MethodInsnNode && this.name == "<init>"

private class UninitializedNewValueMarkerInterpreter : OptimizationBasicInterpreter() {
    val newToCopyUsages = hashMapOf<AbstractInsnNode, MutableSet<AbstractInsnNode>>()
    override fun newOperation(insn: AbstractInsnNode): BasicValue? {
        if (insn.opcode == Opcodes.NEW) {
            newToCopyUsages[insn] = mutableSetOf()
            return UninitializedNewValue(insn as TypeInsnNode, insn.desc)
        }
        return super.newOperation(insn)
    }

    override fun copyOperation(insn: AbstractInsnNode, value: BasicValue?): BasicValue? {
        if (value is UninitializedNewValue) {
            newToCopyUsages[value.anewInsn]!!.add(insn)
            return UninitializedNewValue(value.anewInsn, value.internalName)
        }
        return super.copyOperation(insn, value)
    }

    override fun merge(v: BasicValue, w: BasicValue): BasicValue {
        if (v === w) return v
        if (v === BasicValue.UNINITIALIZED_VALUE || w === BasicValue.UNINITIALIZED_VALUE) {
            return BasicValue.UNINITIALIZED_VALUE
        }

        if (v is UninitializedNewValue || w is UninitializedNewValue) {
            if ((v as? UninitializedNewValue)?.anewInsn !== (w as? UninitializedNewValue)?.anewInsn) {
                // Merge of two different ANEW result is possible, but such values should not be used further
                return BasicValue.UNINITIALIZED_VALUE
            }

            return v
        }

        return super.merge(v, w)
    }
}
